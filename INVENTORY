INVENTORY
-- Decompiler will be improved VERY SOON!
-- Decompiled with Konstant V2.1, a fast Luau decompiler made in Luau by plusgiant5 (https://
discord.gg/brNTY8nX8t)
-- Decompiled on 2025-08-28 19:40:28
-- Luau version 6, Types version 3
-- Time taken: 0.021387 seconds
local module =
require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("Runti
meLib"))
local any_import_result1_upvr = module.import(script, game:GetService("ReplicatedStorage"),
"shared", "result")
local copyMutable_upvr = module.import(script, game:GetService("ReplicatedStorage"), "shared",
"table", "copy").copyMutable
local any_import_result1_2 = module.import(script, game:GetService("ReplicatedStorage"),
"shared", "game", "cards")
local cards_upvr = any_import_result1_2.cards
local splitCardId_upvr = any_import_result1_2.splitCardId
local any_import_result1 = module.import(script, game:GetService("ReplicatedStorage"),
"shared", "game", "rarity")
local dedupeRewards_upvr = module.import(script, game:GetService("ReplicatedStorage"),
"shared", "game", "reward").dedupeRewards
local function addFullCards_upvr(arg1, arg2) -- Line 17, Named "addFullCards"
--[[ Upvalues[1]:
[1]: copyMutable_upvr (readonly)
]]
local var3_result1 = copyMutable_upvr(arg1)
for i, v in pairs(arg2) do
if v ~= 0 then
local var17 = var3_result1[i]
if var17 == nil then
var17 = 0
end
var3_result1[i] = var17 + v
end
end
return var3_result1
end
local function removeFullCards_upvr(arg1, arg2) -- Line 31, Named "removeFullCards"
--[[ Upvalues[2]:
[1]: copyMutable_upvr (readonly)
[2]: any_import_result1_upvr (readonly)
]]
local copyMutable_upvr_result1 = copyMutable_upvr(arg1)
for i_2, v_2 in pairs(arg2) do
local var26 = copyMutable_upvr_result1[i_2]
if var26 == nil then
var26 = 0
end
local var27 = var26
if var27 < v_2 then
return any_import_result1_upvr:err("Insuﬃcient cards")
end
copyMutable_upvr_result1[i_2] = var27 - v_2
end
return any_import_result1_upvr:ok(copyMutable_upvr_result1)
end
local function removeItems_upvr(arg1, arg2) -- Line 46, Named "removeItems"
--[[ Upvalues[2]:
[1]: copyMutable_upvr (readonly)
[2]: any_import_result1_upvr (readonly)
]]
local var3_result1_3 = copyMutable_upvr(arg1)
for i_3, v_3 in pairs(arg2) do
local var36 = var3_result1_3[i_3]
if var36 == nil then
var36 = 0
end
local var37 = var36
if var37 < v_3 then
return any_import_result1_upvr:err("Insuﬃcient items")
end
var3_result1_3[i_3] = var37 - v_3
end
return any_import_result1_upvr:ok(var3_result1_3)
end
local function addItems_upvr(arg1, arg2) -- Line 61, Named "addItems"
--[[ Upvalues[1]:
[1]: copyMutable_upvr (readonly)
]]
local var3_result1_2 = copyMutable_upvr(arg1)
for i_4, v_4 in pairs(arg2) do
local var46 = var3_result1_2[i_4]
if var46 == nil then
var46 = 0
end
var3_result1_2[i_4] = var46 + v_4
end
return var3_result1_2
end
local combineCardCounts_upvr = any_import_result1_2.combineCardCounts
local function giveRewards_upvr(arg1, arg2, arg3) -- Line 84, Named "giveRewards"
--[[ Upvalues[2]:
[1]: addFullCards_upvr (readonly)
[2]: addItems_upvr (readonly)
]]
-- KONSTANTWARNING: Variable analysis failed. Output will have some incorrect variable
assignments
local var58
for _, v_5 in arg3 do
if v_5.type == "card" then
var58 = addFullCards_upvr(var58, {
[v_5.card] = v_5.count;
})
elseif v_5.type == "item" then
end
end
return {
deck = var58;
backpack = addItems_upvr(arg2, {
[v_5.item] = v_5.count;
});
}
end
local iterateParty_upvr = module.import(script, game:GetService("ReplicatedStorage"), "shared",
"game", "party").iterateParty
local function removePartyPosition_upvr(arg1, arg2, arg3) -- Line 215, Named
"removePartyPosition"
--[[ Upvalues[2]:
[1]: any_import_result1_upvr (readonly)
[2]: iterateParty_upvr (readonly)
]]
local var94 = arg1.slots[arg1.activeSlot]
local var95 = var94[arg2]
if not var95[arg3] then
return any_import_result1_upvr:err("Position empty")
end
local var99
for i_8, v_8 in iterateParty_upvr(var95, false) do
if arg3 < i_8 then
local var100 = i_8 - 1
if 0 >= var100 then
var99 = false
else
var99 = true
end
assert(var99)
;({})[var100] = v_8
elseif i_8 ~= arg3 then
;({})[i_8] = v_8
-- KONSTANTERROR: Expression was reused, decompilation is incorrect
end
end
local clone_6 = table.clone(var94)
setmetatable(clone_6, nil)
-- KONSTANTERROR: Expression was reused, decompilation is incorrect
clone_6[arg2] = {}
local clone_7 = table.clone(arg1)
setmetatable(clone_7, nil)
local clone_5 = table.clone(arg1.slots)
setmetatable(clone_5, nil)
clone_5[arg1.activeSlot] = clone_6
clone_7.slots = clone_5
return any_import_result1_upvr:ok({
party = clone_7;
})
end
local function findCardPositions_upvr(arg1, arg2) -- Line 347, Named "findCardPositions"
local module_2 = {}
for i_20, v_16 in pairs(arg1.slots) do
for _, v_17 in {"attack", "support"} do
for i_22, v_18 in pairs(v_16[v_17]) do
if v_18 == arg2 then
table.insert(module_2, {
slot = i_20;
ty = v_17;
position = i_22;
})
end
end
end
end
table.sort(module_2, function(arg1_6, arg2_6) -- Line 363
local var198
if arg1_6.position >= arg2_6.position then
var198 = false
else
var198 = true
end
return var198
end)
return module_2
end
local function removeCardFromParty_upvr(arg1, arg2, arg3) -- Line 368, Named
"removeCardFromParty"
--[[ Upvalues[3]:
[1]: findCardPositions_upvr (readonly)
[2]: removePartyPosition_upvr (readonly)
[3]: any_import_result1_upvr (readonly)
]]
-- KONSTANTERROR: [0] 1. Error Block 13 start (CF ANALYSIS FAILED)
if arg3 <= 0 then
return arg1
end
-- KONSTANTERROR: [0] 1. Error Block 13 end (CF ANALYSIS FAILED)
-- KONSTANTERROR: [55] 42. Error Block 10 start (CF ANALYSIS FAILED)
local clone_2 = table.clone(arg1)
setmetatable(clone_2, nil)
-- KONSTANTWARNING: Failed to evaluate expression, replaced with nil [66.7]
clone_2.activeSlot = nil
-- KONSTANTERROR: [55] 42. Error Block 10 end (CF ANALYSIS FAILED)
-- KONSTANTERROR: [6] 6. Error Block 16 start (CF ANALYSIS FAILED)
-- KONSTANTWARNING: Failed to evaluate expression, replaced with nil [69.131970]
if 0 < arg3 then
-- KONSTANTWARNING: Failed to evaluate expression, replaced with nil [69.6]
if nil ~= 0 then
-- KONSTANTERROR: Expression was reused, decompilation is incorrect
if nil and clone_2 then
-- KONSTANTWARNING: GOTO [55] #42
end
-- KONSTANTWARNING: GOTO [70] #53
end
-- KONSTANTWARNING: GOTO [70] #53
end
-- KONSTANTERROR: [6] 6. Error Block 16 end (CF ANALYSIS FAILED)
end
local function countCardInParty_upvr(arg1, arg2) -- Line 402, Named "countCardInParty"
local var218
for _, v_19 in pairs(arg1.slots) do
local var220
for _, v_20 in {"attack", "support"} do
for _, v_21 in pairs(v_19[v_20]) do
if v_21 == arg2 then
var220 += 1
end
end
end
var218 = math.max(var218, var220)
end
return var218
end
local previousRarity_upvr = any_import_result1.previousRarity
local nextRarity_upvr = any_import_result1.nextRarity
local function mergeCard_upvr(arg1, arg2, arg3) -- Line 455, Named "mergeCard"
--[[ Upvalues[8]:
[1]: splitCardId_upvr (readonly)
[2]: cards_upvr (readonly)
[3]: any_import_result1_upvr (readonly)
[4]: nextRarity_upvr (readonly)
[5]: removeFullCards_upvr (readonly)
[6]: addFullCards_upvr (readonly)
[7]: findCardPositions_upvr (readonly)
[8]: removeCardFromParty_upvr (readonly)
]]
local var6_result1, var6_result2_2 = splitCardId_upvr(arg3)
if cards_upvr[var6_result1].support then
return any_import_result1_upvr:err("Support card")
end
local nextRarity_upvr_result1 = nextRarity_upvr(var6_result2_2)
if nextRarity_upvr_result1 == nil then
return any_import_result1_upvr:err("No next rarity")
end
local var239 = arg1[arg3]
if var239 == nil then
var239 = 0
end
local var240 = var239
local var241 = math.floor(var240 / 100) * 100
if var241 <= 0 then
return any_import_result1_upvr:err("Insuﬃcient cards")
end
local removeFullCards_upvr_result1 = removeFullCards_upvr(arg1, {
[arg3] = var241;
})
if any_import_result1_upvr:isErr(removeFullCards_upvr_result1) then
return any_import_result1_upvr:err("Insuﬃcient cards")
end
local var244 = var241 / 100
return any_import_result1_upvr:ok({
deck = addFullCards_upvr(removeFullCards_upvr_result1.value, {
[`{var6_result1}:{nextRarity_upvr_result1}`] = var244;
});
party = removeCardFromParty_upvr(arg2, arg3, math.max(0,
(#findCardPositions_upvr(arg2, arg3)) - (var240 - var241)));
["in"] = var241;
out = var244;
})
end
local function getCardsAvailableForExploration_upvr(arg1, arg2) -- Line 521, Named
"getCardsAvailableForExploration"
--[[ Upvalues[3]:
[1]: splitCardId_upvr (readonly)
[2]: cards_upvr (readonly)
[3]: countCardInParty_upvr (readonly)
]]
for i_27, v_22 in pairs(arg1) do
if not cards_upvr[splitCardId_upvr(i_27)].support then
local maximum = math.max(0, v_22 - countCardInParty_upvr(arg2, i_27))
if 0 < maximum then
({})[i_27] = maximum
end
end
end
return {}
-- KONSTANTERROR: Expression was reused, decompilation is incorrect
end
local adjustCardForRarity_upvr = any_import_result1_2.adjustCardForRarity
local explorations_upvr = module.import(script, game:GetService("ReplicatedStorage"), "shared",
"game", "explorations").explorations
return {
addFullCards = addFullCards_upvr;
removeFullCards = removeFullCards_upvr;
removeItems = removeItems_upvr;
addItems = addItems_upvr;
setTrait = function(arg1, arg2, arg3, arg4) -- Line 73, Named "setTrait"
--[[ Upvalues[2]:
[1]: combineCardCounts_upvr (readonly)
[2]: any_import_result1_upvr (readonly)
]]
local var48 = combineCardCounts_upvr(arg1)[arg3]
if var48 == nil or var48 == 0 then
return any_import_result1_upvr:err("Card not found")
end
local clone_4 = table.clone(arg2)
setmetatable(clone_4, nil)
clone_4[arg3] = arg4
return any_import_result1_upvr:ok(clone_4)
end;
giveRewards = giveRewards_upvr;
craftRecipe = function(arg1, arg2, arg3, arg4) -- Line 103, Named "craftRecipe"
--[[ Upvalues[4]:
[1]: any_import_result1_upvr (readonly)
[2]: removeFullCards_upvr (readonly)
[3]: removeItems_upvr (readonly)
[4]: giveRewards_upvr (readonly)
]]
if arg1.oneTimeCraft then
if arg4 ~= 1 then
return any_import_result1_upvr:err("Invalid quantity")
end
if arg1.reward.type == "card" and arg2[arg1.reward.card] ~= nil then
return any_import_result1_upvr:err("Already crafted")
end
if arg1.reward.type == "item" and arg3[arg1.reward.item] ~= nil then
return any_import_result1_upvr:err("Already crafted")
end
end
for _, v_6 in arg1.requirements do
if v_6.type == "card" then
local card = v_6.card
local var67 = arg2[card]
if var67 == nil then
var67 = 0
end
if var67 < v_6.count * arg4 then
return any_import_result1_upvr:err("Requirements not met")
end
;({})[card] = v_6.count * arg4
elseif v_6.type == "item" then
local item = v_6.item
var67 = arg3[item]
local var69 = var67
if var69 == nil then
var69 = 0
end
if var69 < v_6.count * arg4 then
return any_import_result1_upvr:err("Requirements not met")
end
;({})[item] = v_6.count * arg4
end
end
-- KONSTANTERROR: Expression was reused, decompilation is incorrect
local removeFullCards_result1 = removeFullCards_upvr(arg2, {})
if not any_import_result1_upvr:isOk(removeFullCards_result1) then
return any_import_result1_upvr:err("Requirements not met")
end
-- KONSTANTERROR: Expression was reused, decompilation is incorrect
local removeItems_result1 = removeItems_upvr(arg3, {})
if not any_import_result1_upvr:isOk(removeItems_result1) then
return any_import_result1_upvr:err("Requirements not met")
end
local clone_3 = table.clone(arg1.reward)
setmetatable(clone_3, nil)
clone_3.count = arg1.reward.count * arg4
return
any_import_result1_upvr:ok(giveRewards_upvr(removeFullCards_result1.value,
removeItems_result1.value, {clone_3}))
end;
addCardToParty = function(arg1, arg2, arg3) -- Line 156, Named "addCardToParty"
--[[ Upvalues[3]:
[1]: any_import_result1_upvr (readonly)
[2]: splitCardId_upvr (readonly)
[3]: cards_upvr (readonly)
]]
-- KONSTANTWARNING: Variable analysis failed. Output will have some incorrect
variable assignments
-- KONSTANTERROR: [0] 1. Error Block 73 start (CF ANALYSIS FAILED)
local var82 = arg1[arg3]
if var82 == nil then
var82 = 0
end
local var83 = var82
if var83 <= 0 then
return any_import_result1_upvr:err("Insuﬃcient cards")
end
local var84
if cards_upvr[splitCardId_upvr(arg3)].support then
var84 = "support"
else
var84 = "attack"
end
local var85 = arg2.slots[arg2.activeSlot][var84]
for _, v_7 in pairs(var85) do
if v_7 == arg3 then
end
end
if var83 <= 0 + 1 then
return any_import_result1_upvr:err("Insuﬃcient cards")
end
if var85[1] == nil then
else
end
if not true then
-- KONSTANTWARNING: GOTO [84] #70
end
if var85[2] == nil then
-- KONSTANTWARNING: GOTO [65] #53
end
-- KONSTANTERROR: [0] 1. Error Block 73 end (CF ANALYSIS FAILED)
-- KONSTANTERROR: [64] 52. Error Block 71 start (CF ANALYSIS FAILED)
if not true then
-- KONSTANTWARNING: GOTO [84] #70
end
-- KONSTANTERROR: [64] 52. Error Block 71 end (CF ANALYSIS FAILED)
end;
removePartyPosition = removePartyPosition_upvr;
advanceRaidProgress = function(arg1, arg2, arg3, arg4) -- Line 249, Named
"advanceRaidProgress"
--[[ Upvalues[2]:
[1]: any_import_result1_upvr (readonly)
[2]: dedupeRewards_upvr (readonly)
]]
-- KONSTANTERROR: [0] 1. Error Block 45 start (CF ANALYSIS FAILED)
if arg4 == nil then
end
local var117 = arg3[#arg3]
if var117 == nil then
return any_import_result1_upvr:err("Threshold missing")
end
local var118 = arg1 + arg2
local floored = math.floor(var118 / var117.threshold)
local var120 = var118 % var117.threshold
local tbl_upvr_4 = {}
local tbl_upvr_2 = {}
local function _(arg1_2, arg2_2) -- Line 262
for _, v_9 in arg2_2 do
table.insert(arg1_2, v_9)
end
end
local function var126(arg1_3, arg2_3) -- Line 267
--[[ Upvalues[3]:
[1]: arg3 (readonly)
[2]: tbl_upvr_4 (readonly)
[3]: tbl_upvr_2 (readonly)
]]
-- KONSTANTWARNING: Variable analysis failed. Output will have some
incorrect variable assignments
for i_10 = 1, #arg3 do
local var147 = arg3[i_10]
if var147 and arg1_3 < var147.threshold and var147.threshold <=
arg2_3 then
if var147.type == 0 then
for _, v_10 in var147.rewards do
table.insert(tbl_upvr_4, v_10)
local var148
else
end
var148 = var147.type
if var148 == 1 then
var148 = tbl_upvr_2
for _, v_11 in var147.globalEvents do
table.insert(var148, v_11)
local _
end
end
end
end
end
end
var126(arg1, math.min(var117.threshold, var118))
local var150 = var120
if not false then
for i_13 = 1, math.max(0, floored - 1) do
for i_14 = 1, #arg3 do
local var151 = arg3[i_14]
if var151 then
if var151.type == 0 then
for _, v_12 in var151.rewards do
table.insert(tbl_upvr_4, v_12)
local var152
end
elseif var151.type == 1 then
for _, v_25 in var151.globalEvents do
table.insert(tbl_upvr_2, v_25)
local var153
end
end
end
end
end
if 0 < floored then
i_13 = var120
var126(0, i_13)
-- KONSTANTWARNING: GOTO [121] #93
end
else
i_13 = var117.threshold
var150 = math.min(var118, i_13)
end
-- KONSTANTERROR: [0] 1. Error Block 45 end (CF ANALYSIS FAILED)
-- KONSTANTERROR: [121] 93. Error Block 23 start (CF ANALYSIS FAILED)
do
return any_import_result1_upvr:ok({
damage = var150;
rewards = dedupeRewards_upvr(var152);
globalEvents = var153;
})
end
-- KONSTANTERROR: [121] 93. Error Block 23 end (CF ANALYSIS FAILED)
end;
getIntervalResults = function(arg1, arg2, arg3) -- Line 310, Named "getIntervalResults"
--[[ Upvalues[2]:
[1]: any_import_result1_upvr (readonly)
[2]: dedupeRewards_upvr (readonly)
]]
local tbl_upvr = {}
local tbl_upvr_3 = {}
local function _(arg1_4, arg2_4) -- Line 314
for _, v_13 in arg2_4 do
table.insert(arg1_4, v_13)
end
end
;(function(arg1_5, arg2_5) -- Line 319
--[[ Upvalues[3]:
[1]: arg3 (readonly)
[2]: tbl_upvr (readonly)
[3]: tbl_upvr_3 (readonly)
]]
-- KONSTANTWARNING: Variable analysis failed. Output will have some
incorrect variable assignments
-- KONSTANTERROR: [0] 1. Error Block 33 start (CF ANALYSIS FAILED)
-- KONSTANTWARNING: Failed to evaluate expression, replaced with nil
[4.6]
if nil.every <= 0 then
warn("Intervals must be greater than 0")
-- KONSTANTWARNING: GOTO [4] #5
end
-- KONSTANTERROR: [0] 1. Error Block 33 end (CF ANALYSIS FAILED)
-- KONSTANTERROR: [14] 12. Error Block 27 start (CF ANALYSIS FAILED)
-- KONSTANTWARNING: Failed to evaluate expression, replaced with nil
[103.9]
if nil ~= nil then
end
-- KONSTANTWARNING: Failed to evaluate expression, replaced with nil
[103.12]
-- KONSTANTWARNING: Failed to evaluate expression, replaced with nil
[103.10]
-- KONSTANTWARNING: Failed to evaluate expression, replaced with nil
[103.11]
for _ = nil, nil, nil do
-- KONSTANTWARNING: Failed to evaluate expression, replaced
with nil [103.13]
if nil == 0 then
-- KONSTANTWARNING: Failed to evaluate expression,
replaced with nil [103.15]
-- KONSTANTWARNING: Failed to evaluate expression,
replaced with nil [103.16]
-- KONSTANTWARNING: Failed to evaluate expression,
replaced with nil [103.17]
for _, _ in nil do
end
else
-- KONSTANTERROR: Expression was reused,
decompilation is incorrect
if nil == 1 then
for _, _ in nil do
-- KONSTANTERROR: Expression was reused,
decompilation is incorrect (x3)
end
end
(x3)
end
end
-- KONSTANTERROR: Expression was reused, decompilation is incorrect
-- KONSTANTERROR: [14] 12. Error Block 27 end (CF ANALYSIS FAILED)
end)(arg1, arg1 + arg2)
return any_import_result1_upvr:ok({
rewards = dedupeRewards_upvr(tbl_upvr);
globalEvents = tbl_upvr_3;
})
end;
deconstructCard = function(arg1, arg2, arg3) -- Line 417, Named "deconstructCard"
--[[ Upvalues[8]:
[1]: splitCardId_upvr (readonly)
[2]: cards_upvr (readonly)
[3]: any_import_result1_upvr (readonly)
[4]: previousRarity_upvr (readonly)
[5]: removeFullCards_upvr (readonly)
[6]: addFullCards_upvr (readonly)
[7]: findCardPositions_upvr (readonly)
[8]: removeCardFromParty_upvr (readonly)
]]
local var6_result1_3, var6_result2 = splitCardId_upvr(arg3)
if cards_upvr[var6_result1_3].support then
return any_import_result1_upvr:err("Support card")
end
local previousRarity_upvr_result1 = previousRarity_upvr(var6_result2)
if previousRarity_upvr_result1 == nil then
return any_import_result1_upvr:err("No previous rarity")
end
local var228 = arg1[arg3]
if var228 == nil then
var228 = 0
end
local var229 = var228
if var229 <= 0 then
return any_import_result1_upvr:err("Insuﬃcient cards")
end
local removeFullCards_result1_2 = removeFullCards_upvr(arg1, {
[arg3] = var229;
})
if any_import_result1_upvr:isErr(removeFullCards_result1_2) then
return any_import_result1_upvr:err("Insuﬃcient cards")
end
local var232 = var229 * 100
return any_import_result1_upvr:ok({
deck = addFullCards_upvr(removeFullCards_result1_2.value, {
[`{var6_result1_3}:{previousRarity_upvr_result1}`] = var232;
});
party = removeCardFromParty_upvr(arg2, arg3,
#findCardPositions_upvr(arg2, arg3));
["in"] = var229;
out = var232;
})
end;
mergeCard = mergeCard_upvr;
mergeAll = function(arg1, arg2) -- Line 496, Named "mergeAll"
--[[ Upvalues[2]:
[1]: mergeCard_upvr (readonly)
[2]: any_import_result1_upvr (readonly)
]]
-- KONSTANTWARNING: Variable analysis failed. Output will have some incorrect
variable assignments
local var254
for i_26 in pairs(arg1) do
local mergeCard_upvr_result1 = mergeCard_upvr(var254, arg2, i_26)
if not any_import_result1_upvr:isErr(mergeCard_upvr_result1) then
var254 = mergeCard_upvr_result1.value.deck
end
end
if var254 == arg1 then
return any_import_result1_upvr:err("Insuﬃcient cards")
end
return any_import_result1_upvr:ok({
deck = var254;
party = mergeCard_upvr_result1.value.party;
["in"] = 0 + mergeCard_upvr_result1.value["in"];
out = 0 + mergeCard_upvr_result1.value.out;
})
end;
getCardsAvailableForExploration = getCardsAvailableForExploration_upvr;
canUseCardsForExploration = function(arg1, arg2, arg3, arg4) -- Line 537, Named
"canUseCardsForExploration"
--[[ Upvalues[5]:
[1]: getCardsAvailableForExploration_upvr (readonly)
[2]: splitCardId_upvr (readonly)
[3]: adjustCardForRarity_upvr (readonly)
[4]: any_import_result1_upvr (readonly)
[5]: explorations_upvr (readonly)
]]
for i_28, v_23 in pairs(arg3) do
local var6_result1_2, var6_result2_3 = splitCardId_upvr(i_28)
local adjustCardForRarity_upvr_result1 =
adjustCardForRarity_upvr(var6_result1_2, var6_result2_3)
if adjustCardForRarity_upvr_result1.support then
return any_import_result1_upvr:err("Support card cannot be used in
exploration")
end
local var275 = getCardsAvailableForExploration_upvr(arg1, arg2)[i_28]
if var275 == nil then
var275 = 0
end
if var275 < v_23 then
return any_import_result1_upvr:err("Insuﬃcient cards")
end
if adjustCardForRarity_upvr_result1.denom <
explorations_upvr[arg4].minDenom then
return any_import_result1_upvr:err("Insuﬃcient denominator")
end
end
return any_import_result1_upvr:ok(nil)
end;
getMaxCraftQuantity = function(arg1, arg2, arg3) -- Line 559, Named
"getMaxCraftQuantity"
local var288
for i_29, v_24 in arg1.requirements do
if v_24.type == "card" then
local var289 = arg2[v_24.card]
if var289 == nil then
var289 = 0
end
var288 = math.min(var288, math.floor(var289 / v_24.count))
elseif v_24.type == "item" then
var289 = arg3[v_24.item]
local var290 = var289
if var290 == nil then
var290 = 0
end
var288 = math.min(var288, math.floor(var290 / v_24.count))
end
end
local var291
if var291 then
var291 = false
if arg1.reward.type == "card" then
i_29 = arg1.reward
if arg2[i_29.card] ~= nil then
var291 = true
end
end
if arg1.reward.type == "item" then
i_29 = arg1.reward
if arg3[i_29.item] ~= nil then
var291 = true
end
end
if var291 then
return 0
end
i_29 = var288
return math.min(1, i_29)
end
return math.max(0, math.floor(var288))
end;
}
